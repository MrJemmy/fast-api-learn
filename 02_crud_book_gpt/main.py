from datetime import date
from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel, Field
from typing import Optional, List  # Explicitly import List for type hints

# --- App Initialization ---
app = FastAPI(
    title="Book CRUD API",
    description=(
        "A simple, best-practice implementation of CRUD operations "
        "for a Book resource."
    ),
)

# --- Pydantic Models for Data Validation and Serialization ---

# 1. Base Schema for Request Body (Creation/Update)


class BookBase(BaseModel):
    # Required Fields (using ... means mandatory)
    title: str = Field(
        ...,
        json_schema_extra={"example": "The Hitchhiker's Guide to the Galaxy"}
    )
    author: str = Field(..., json_schema_extra={"example": "Douglas Adams"})
    publisher: str = Field(..., json_schema_extra={"example": "Pan Books"})
    published_date: date = Field(
        ...,
        json_schema_extra={
            "example": f"{date(1979, 10, 12)}",
            "description": "The date the book was first published."}
    )
    # gt=0 ensures the count is greater than zero
    page_count: int = Field(..., gt=0, json_schema_extra={"example": 224})
    language: str = Field(..., json_schema_extra={"example": "English"})

    # Optional Fields
    isbn: Optional[str] = Field(None, json_schema_extra={
                                "example": "978-0345391803"})
    is_published: Optional[bool] = Field(
        None, json_schema_extra={"example": "True"})

# 2. Schema for the complete Book object (Response Model)
# Adds the unique ID, which is typically generated by the database/server


class Book(BookBase):
    id: int = Field(..., json_schema_extra={
                    "example": "1",
                    "description": "Unique identifier for the book."})

    class Config:
        # Enables conversion from non-dict objects (like SQLAlchemy models)
        from_attributes = True


# --- Sample Data (In-Memory Database) ---
BOOKS_DB = {
    1: Book(
        id=1,
        title="Dune",
        author="Frank Herbert",
        publisher="Chilton Books",
        published_date=date(1965, 8, 1),
        page_count=412,
        language="English",
        isbn=None,
        is_published=None
    ),
    2: Book(
        id=2,
        title="The Name of the Wind",
        author="Patrick Rothfuss",
        publisher="DAW Books",
        published_date=date(2007, 3, 27),
        page_count=662,
        language="English",
        isbn=None,
        is_published=None
    )
}
next_id = 3

# --- Home Route ---


@app.get("/")
async def read_root():
    return {"message": ("Welcome to the Book CRUD API. Go to /docs for"
                        "interactive documentation.")}

# ==============================================================================
# ðŸš€ CRUD Path Operations (Best Implementation)
# ==============================================================================

# CREATE (POST)
# Uses Pydantic (BookBase) for request data and status_code=201 for success


@app.post("/books/", response_model=Book, status_code=status.HTTP_201_CREATED)
async def create_book(book_data: BookBase):
    """Creates a new book."""
    global next_id

    # **REQUEST DATA ACCESS:** FastAPI provides the validated Pydantic object
    # `book_data`
    new_book = Book(id=next_id, **book_data.model_dump())
    BOOKS_DB[next_id] = new_book
    next_id += 1

    return new_book

# ------------------------------------------------------------------------------

# READ ALL (GET)
# Uses default status_code=200 for success


@app.get("/books/", response_model=List[Book])
async def read_all_books():
    """Retrieves a list of all books."""
    return list(BOOKS_DB.values())

# ------------------------------------------------------------------------------

# READ ONE (GET)
# Uses HTTPException for error status_code=404


@app.get("/books/{book_id}", response_model=Book)
async def read_book(book_id: int):
    """Retrieves a specific book by ID."""
    # **REQUEST DATA ACCESS:** Path parameter `book_id` is automatically
    # parsed as int
    if book_id not in BOOKS_DB:
        # **STATUS CODE (ERROR):** Best way to signal a client error (4xx)
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Book with ID {book_id} not found"
        )
    return BOOKS_DB[book_id]

# ------------------------------------------------------------------------------

# UPDATE (PUT)
# Uses Pydantic (BookBase) for request data and HTTPException for error
# status_code=404


@app.put("/books/{book_id}", response_model=Book)
# Corrected to use BookBase
async def update_book(book_id: int, book_data: BookBase):
    """Updates an existing book by ID."""
    # **REQUEST DATA ACCESS:** Access path parameter `book_id` and body
    # `book_data`
    if book_id not in BOOKS_DB:
        # **STATUS CODE (ERROR):** 404 Not Found
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Book with ID {book_id} not found"
        )

    updated_book = Book(id=book_id, **book_data.model_dump())
    BOOKS_DB[book_id] = updated_book

    return updated_book

# ------------------------------------------------------------------------------

# DELETE (DELETE)
# Uses status_code=204 for success (no content returned) and HTTPException for
# error status_code=404


@app.delete("/books/{book_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_book(book_id: int):
    """Deletes a book by ID."""
    # **REQUEST DATA ACCESS:** Access path parameter `book_id`
    if book_id not in BOOKS_DB:
        # **STATUS CODE (ERROR):** 404 Not Found
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Book with ID {book_id} not found"
        )

    del BOOKS_DB[book_id]

    # **STATUS CODE (SUCCESS):** Return None for HTTP 204 No Content
    return
